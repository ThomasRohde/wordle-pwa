// Custom service worker functionality
// This extends the default Workbox service worker

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies'

declare let self: ServiceWorkerGlobalScope

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST)

// Clean up old caches
cleanupOutdatedCaches()

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
)

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          return `${request.url}`
        },
      },
    ],
  })
)

// Handle background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(doBackgroundSync())
  }
})

async function doBackgroundSync() {
  // Handle any queued actions when back online
  console.log('Background sync triggered')
  
  try {
    // Check if there are any pending game actions to sync
    const pendingActions = await getFromIndexedDB('pending-actions')
    
    if (pendingActions && pendingActions.length > 0) {
      // Process pending actions
      for (const action of pendingActions) {
        await processAction(action)
      }
      
      // Clear processed actions
      await clearFromIndexedDB('pending-actions')
    }
  } catch (error) {
    console.error('Background sync failed:', error)
  }
}

async function processAction(action: any) {
  // Process queued actions (placeholder for future features)
  console.log('Processing action:', action)
}

// IndexedDB helpers for offline queue
async function getFromIndexedDB(key: string) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('wordle-pwa-db', 1)
    
    request.onerror = () => reject(request.error)
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['offline-queue'], 'readonly')
      const store = transaction.objectStore('offline-queue')
      const getRequest = store.get(key)
      
      getRequest.onerror = () => reject(getRequest.error)
      getRequest.onsuccess = () => resolve(getRequest.result)
    }
    
    request.onupgradeneeded = () => {
      const db = request.result
      if (!db.objectStoreNames.contains('offline-queue')) {
        db.createObjectStore('offline-queue')
      }
    }
  })
}

async function clearFromIndexedDB(key: string) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('wordle-pwa-db', 1)
    
    request.onerror = () => reject(request.error)
    request.onsuccess = () => {
      const db = request.result
      const transaction = db.transaction(['offline-queue'], 'readwrite')
      const store = transaction.objectStore('offline-queue')
      const deleteRequest = store.delete(key)
      
      deleteRequest.onerror = () => reject(deleteRequest.error)
      deleteRequest.onsuccess = () => resolve(deleteRequest.result)
    }
  })
}

// Handle push notifications
self.addEventListener('push', (event) => {
  if (!event.data) return

  const data = event.data.json()
  const options = {
    body: data.body,
    icon: '/icons/pwa-192x192.png',
    badge: '/icons/pwa-192x192.png',
    tag: 'wordle-notification',
    requireInteraction: false,
    actions: [
      {
        action: 'play',
        title: 'Play Now'
      },
      {
        action: 'close',
        title: 'Close'
      }
    ]
  }

  event.waitUntil(
    self.registration.showNotification(data.title || 'Wordle PWA', options)
  )
})

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close()

  if (event.action === 'play') {
    event.waitUntil(
      self.clients.openWindow('/')
    )
  }
})

// Offline fallback
const OFFLINE_VERSION = 1
const CACHE_NAME = 'offline-html'
const OFFLINE_URL = '/offline.html'

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.add(OFFLINE_URL))
  )
})

self.addEventListener('fetch', (event) => {
  // Only handle navigation requests for HTML pages
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.open(CACHE_NAME).then((cache) => {
          return cache.match(OFFLINE_URL)
        })
      })
    )
  }
})

console.log('Wordle PWA Service Worker loaded')
